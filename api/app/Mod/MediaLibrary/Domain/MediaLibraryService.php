<?php

namespace App\Mod\MediaLibrary\Domain;

use App\Domain\BaseService;
use Symfony\Component\HttpFoundation\Request;
use App\Mod\MediaLibrary\Domain\Models\MediaLibrary;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;
use App\Domain\AwsService;
use App\Core\Contract\Domain\Models\ContractCompany;

/**
 * @property MediaLibrary $model
 */
class MediaLibraryService extends BaseService
{

    public function __construct(MediaLibrary $model)
    {
        parent::__construct($model);
    }

    public function findList(Request $request, ?int $limit = null, array $with = [], string $flatMethod = 'toFlatArray'): array
    {
        if (!$limit) {
            $limit = config('media_library.list.limit');
        }
        return parent::findList($request, $limit, $with, $flatMethod); // TODO: Change the autogenerated stub
    }

    public function appendCriteria(?array $criteria = [], $query): void
    {
        // 画像のみのフィルタ（criteria[only_image]=1）
        if (!empty($criteria['only_image'])) {
            $query->where('mime_type', 'like', 'image/%');
            unset($criteria['only_image']);
        }

        parent::appendCriteria($criteria, $query);
    }

    public function validateRequest(Request $request, mixed $post = null): void
    {
        $request->validate(
            [
                "file_name" => ['required'],
            ],
            [
                'title.file_name' => 'タイトルは必須項目です。',
            ]
        );
    }

    /**
     * 追加
     */
    public function store(Request $request): array
    {
        return $this->chunkUpload($request);
    }

    /**
     * メディア変更
     */
    public function updateMedia(Request $request, mixed $id = null): array
    {
        $beforeModel = $this->model->find($id);
        // チャンクアップロード
        $result = $this->chunkUpload($request, $id);

        if ($result['status'] === 'completed') {
            // ファイル削除（ストレージからの相対パスを絶対パスに変換
            $this->deleteFileDirectory($beforeModel->file_path, $beforeModel->company);
        }

        return $result;
    }

    /**
     * 更新時
     */
    public function beforeSave(Request $request, MediaLibrary $model, array &$inputs): void
    {
        unset($inputs['file']);

        // ファイル名が変更された場合
        if (isset($inputs['file_name']) && $inputs['file_name'] !== $model->file_name) {
            $this->renameMedia($model, $inputs['file_name']);
        }
    }

    public function afterSave(Request $request, MediaLibrary $model, mixed $id = null): void
    {
        // 施設に紐づけ
        $companyAndFacility = $this->findCompanyAndFacility($request);
        $company = $companyAndFacility['company'];
        $facility = $companyAndFacility['facility'];

        $model->company_id = $company->id;
        $model->assignable_type = get_class($facility);
        $model->assignable_id = $facility->id;
        $model->save();
    }

    /**
     * 削除後実行
     */
    public function afterDelete(Request $request, MediaLibrary $model): void
    {
        // ファイルディレクトリを削除
        $this->deleteFileDirectory($model->file_path, $model->company);
    }

    /**
     * ファイルディレクトリを削除
     */
    private function deleteFileDirectory(string $relativePath, ?ContractCompany $company = null): void
    {
        $disk = $this->getStorageDisk();

        // Storage経由でファイルを削除
        if ($disk === 's3') {
            $awsService = AwsService::getInstance();
            $awsService->deleteFile($company->alias, $relativePath);
        } else {
            if (Storage::disk($disk)->exists($relativePath)) {
                Storage::disk($disk)->delete($relativePath);
            }
        }
    }

    /**
     * ストレージディスクを取得
     */
    private function getStorageDisk(): string
    {
        return config('media_library.storage.disk', 'public');
    }

    /**
     * 企業のバケット名を取得
     */
    private function getCompanyBucketName(?ContractCompany $company = null): ?string
    {
        if (!$company) {
            return null;
        }

        $awsService = AwsService::getInstance();
        $bucketName = $awsService->generateBucketName($company->alias);
        return $bucketName;
    }

    /**
     * 企業用のS3ディスク設定を取得
     */
    private function getCompanyS3DiskConfig(?ContractCompany $company = null): array
    {
        $bucketName = $this->getCompanyBucketName($company);

        if (!$bucketName) {
            // バケット名が取得できない場合はデフォルト設定を使用
            return config('filesystems.disks.s3');
        }

        // デフォルトのS3設定を取得
        $s3Config = config('filesystems.disks.s3');

        // バケット名を動的に変更
        $s3Config['bucket'] = $bucketName;

        return $s3Config;
    }

    /**
     * 企業用のS3ディスクを使用してファイルを保存
     */
    private function saveFileToCompanyS3(string $relativePath, string $tempFilePath, ?ContractCompany $company = null, string $mimeType = 'application/octet-stream'): void
    {
        if (!$company) {
            throw new \InvalidArgumentException('企業情報が取得できません。');
        }

        $awsService = AwsService::getInstance();
        $awsService->uploadFile($company->alias, $relativePath, file_get_contents($tempFilePath), $mimeType);
    }

    /**
     * ファイルをリトライとフォールバック機能付きで保存
     *
     * @param string $disk ストレージディスク
     * @param string $relativePath 保存先の相対パス
     * @param string $tempFilePath 一時ファイルのパス
     * @param ContractCompany|null $company 企業情報（S3の場合に使用）
     * @return string 実際に使用したストレージディスク
     * @throws \Exception すべての保存試行が失敗した場合
     */
    private function saveFileWithRetryAndFallback(string $disk, string $relativePath, string $tempFilePath, ?ContractCompany $company = null, string $mimeType = 'application/octet-stream'): string
    {
        $maxRetries = 2;
        $retryCount = 0;
        $fileContent = file_get_contents($tempFilePath);

        // 最初のディスクでリトライ
        while ($retryCount <= $maxRetries) {
            try {
                if ($disk === 's3' && $company) {
                    // S3の場合、企業用のバケットに直接アップロード
                    $this->saveFileToCompanyS3($relativePath, $tempFilePath, $company, $mimeType);
                    return $disk;
                } else {
                    // その他のディスクは通常通り
                    Storage::disk($disk)->put($relativePath, $fileContent);
                    return $disk;
                }
            } catch (\Exception $e) {
                $retryCount++;

                // リトライ上限に達した場合
                if ($retryCount > $maxRetries) {
                    // S3へのアップロードが失敗した場合、publicストレージにフォールバック
                    if ($disk === 's3') {
                        \Log::warning('S3 upload failed after retries, falling back to public storage', [
                            'path' => $relativePath,
                            'retries' => $retryCount - 1,
                            'error' => $e->getMessage(),
                            'bucket' => $company ? $this->getCompanyBucketName($company) : 'default'
                        ]);

                        try {
                            // publicストレージに保存
                            Storage::disk('public')->put($relativePath, $fileContent);
                            return 'public';
                        } catch (\Exception $fallbackException) {
                            // フォールバックも失敗した場合は例外をスロー
                            \Log::error('File upload failed on both S3 and public storage', [
                                's3_error' => $e->getMessage(),
                                'public_error' => $fallbackException->getMessage()
                            ]);
                            throw new \Exception('ファイルのアップロードに失敗しました。しばらく時間をおいて再度お試しください。', 0, $fallbackException);
                        }
                    } else {
                        // publicストレージでも失敗した場合は例外をスロー
                        \Log::error('File upload failed after retries', [
                            'disk' => $disk,
                            'path' => $relativePath,
                            'retries' => $retryCount - 1,
                            'error' => $e->getMessage()
                        ]);
                        throw new \Exception('ファイルのアップロードに失敗しました。しばらく時間をおいて再度お試しください。', 0, $e);
                    }
                }

                // リトライ前に少し待機（指数バックオフ）
                usleep(100000 * $retryCount); // 0.1秒、0.2秒...
            }
        }

        // ここには到達しないはずだが、念のため
        throw new \Exception('ファイルのアップロードに失敗しました。');
    }

    /**
     * ファイルURLを取得
     */
    private function getFileUrl(string $disk, string $relativePath, ?ContractCompany $company = null): string
    {
        if ($disk === 's3') {

            $bucketName = $company ? $this->getCompanyBucketName($company) : config('filesystems.disks.s3.bucket');

            // LocalStackのエンドポイントを使用してURLを生成
            $endpoint = $s3Config['endpoint'] ?? null;
            $usePathStyle = $s3Config['use_path_style_endpoint'] ?? false;

            // AWS_URLが設定されている場合はそれを使用
            $awsUrl = $s3Config['url'] ?? null;
            if ($awsUrl) {
                return rtrim($awsUrl, '/') . '/' . ltrim($relativePath, '/');
            }

            // LocalStackの場合、エンドポイントのホスト名をlocalhostに変換
            if ($endpoint && str_contains($endpoint, 'localstack')) {
                $endpoint = str_replace('localstack', 'localhost', $endpoint);
            }

            if ($usePathStyle && $endpoint && $bucketName) {
                // パススタイル: http://localhost:4566/bucket-name/path/to/file
                return rtrim($endpoint, '/') . '/' . $bucketName . '/' . ltrim($relativePath, '/');
            } elseif ($endpoint && $bucketName) {
                // バーチャルホストスタイル: http://bucket-name.localhost:4566/path/to/file
                $host = parse_url($endpoint, PHP_URL_HOST);
                $port = parse_url($endpoint, PHP_URL_PORT);
                $scheme = parse_url($endpoint, PHP_URL_SCHEME) ?: 'http';
                return $scheme . '://' . $bucketName . '.' . $host . ($port ? ':' . $port : '') . '/' . ltrim($relativePath, '/');
            }

            // バケット名が取得できない場合はデフォルトのStorage URL生成を試みる
            $awsService = AwsService::getInstance();
            return $awsService->getFileUrl($company->alias, $relativePath);
        }

        // デフォルトのStorage URL生成
        return Storage::disk($disk)->url($relativePath);
    }

    /**
     * チャンクアップロード
     */
    protected function chunkUpload(Request $request, mixed $id = null): array
    {
        $originalFileName = $request->input('fileName'); // 元のファイル名（表示用）
        $chunkIndex = (int)$request->input('chunkIndex'); // 今のチャンク番号
        $totalChunks = (int)$request->input('totalChunks'); // 全部で何チャンクか
        $chunk = $request->file('file'); // 今回のチャンクデータ

        // 拡張子を取得
        $extension = strtolower(pathinfo($originalFileName, PATHINFO_EXTENSION));

        // 同じファイルのチャンクを識別するための一意の識別子を生成
        // ファイル名、totalChunks、ユーザーID、IPアドレスから基本キーを生成
        $userId = auth()->id() ?? 0;
        $ipAddress = $request->ip();
        $baseKey = md5($originalFileName . $totalChunks . $userId . $ipAddress);
        $sessionKey = 'upload_id_' . $baseKey;

        // 最初のチャンク（chunkIndex=0）の場合、タイムスタンプを追加してuploadIdを生成し、セッションに保存
        if ($chunkIndex === 0) {
            $microtime = microtime(true);
            $uploadId = md5($baseKey . $microtime);
            // セッションに保存（後続のチャンクで使用）
            session([$sessionKey => $uploadId]);
        } else {
            // 後続のチャンクの場合、セッションからuploadIdを取得
            $uploadId = session($sessionKey);
            if (!$uploadId) {
                // セッションにない場合（最初のチャンクがまだ処理されていない）、エラー
                throw new \Exception('最初のチャンクがまだ処理されていません。チャンクを順番に送信してください。');
            }
        }

        $randomFileName = substr($uploadId, 0, 40) . '.' . $extension;

        // 一時保存ディレクトリ（同じファイルのチャンクは同じディレクトリを使用）
        $tmpDir = storage_path('app/chunks/' . $randomFileName);
        if (!is_dir($tmpDir)) {
            if (!mkdir($tmpDir, 0777, true)) {
                throw new \Exception('一時ディレクトリの作成に失敗しました。');
            }
        }

        // チャンクを一時保存 (例: randomstring.jpg.part0)
        $chunkFileName = $randomFileName . '.part' . $chunkIndex;
        $chunkFilePath = $tmpDir . '/' . $chunkFileName;

        try {
            $chunk->move($tmpDir, $chunkFileName);

            // ファイルが正しく保存されたか確認（最大1秒待機）
            $maxCheckTime = 1; // 秒
            $checkStartTime = time();
            while (!file_exists($chunkFilePath) && (time() - $checkStartTime) < $maxCheckTime) {
                usleep(100000); // 0.1秒待機
            }

            if (!file_exists($chunkFilePath)) {
                throw new \Exception("チャンクファイルの保存に失敗しました: {$chunkIndex}");
            }

            // ファイルが書き込み完了するまで少し待機（ファイルシステムの遅延を考慮）
            usleep(50000); // 0.05秒待機
        } catch (\Exception $e) {
            \Log::error('Chunk save failed', [
                'chunkIndex' => $chunkIndex,
                'totalChunks' => $totalChunks,
                'fileName' => $originalFileName,
                'error' => $e->getMessage()
            ]);
            throw new \Exception("チャンクの保存に失敗しました: {$chunkIndex}/{$totalChunks}", 0, $e);
        }

        // 最後のチャンクならファイルを結合
        if ($chunkIndex + 1 === $totalChunks) {
            $date = new \DateTime();
            $disk = $this->getStorageDisk();

            // 一時ファイルに結合
            $tempFinalPath = storage_path('app/temp/' . $randomFileName);
            $tempDir = dirname($tempFinalPath);
            if (!is_dir($tempDir)) {
                mkdir($tempDir, 0777, true);
            }

            // 最後のチャンクが保存されるまで少し待機
            usleep(200000); // 0.2秒待機

            // すべてのチャンクが揃うまで待機（最大60秒）
            $maxWaitTime = 60; // 秒
            $startTime = time();
            $allChunksReady = false;

            while (!$allChunksReady && (time() - $startTime) < $maxWaitTime) {
                $allChunksReady = true;
                $missingChunks = [];

                for ($i = 0; $i < $totalChunks; $i++) {
                    $chunkFile = $tmpDir . '/' . $randomFileName . '.part' . $i;
                    if (!file_exists($chunkFile)) {
                        $allChunksReady = false;
                        $missingChunks[] = $i;
                    }
                }

                if (!$allChunksReady) {
                    usleep(200000); // 0.2秒待機
                }
            }

            // すべてのチャンクが揃っているか最終確認
            $missingChunks = [];
            $existingChunks = [];
            for ($i = 0; $i < $totalChunks; $i++) {
                $chunkFile = $tmpDir . '/' . $randomFileName . '.part' . $i;
                if (!file_exists($chunkFile)) {
                    $missingChunks[] = $i;
                } else {
                    $existingChunks[] = $i;
                }
            }

            if (!empty($missingChunks)) {
                // 不足しているチャンクがある場合はエラー
                // 特に最初のチャンク（チャンク0）が不足している場合は、フロントエンド側の問題の可能性が高い
                $errorMessage = 'ファイルのアップロードに失敗しました。';
                if (in_array(0, $missingChunks)) {
                    $errorMessage .= ' 最初のチャンクが受信されませんでした。ネットワーク接続を確認して再度お試しください。';
                } else {
                    $errorMessage .= ' 一部のチャンクが受信されませんでした。再度お試しください。';
                }

                \Log::error('Missing chunks for file upload', [
                    'fileName' => $originalFileName,
                    'missingChunks' => $missingChunks,
                    'totalChunks' => $totalChunks,
                    'waitTime' => time() - $startTime
                ]);

                // 到着したチャンクをクリーンアップ
                foreach ($existingChunks as $existingChunkIndex) {
                    $chunkFile = $tmpDir . '/' . $randomFileName . '.part' . $existingChunkIndex;
                    if (file_exists($chunkFile)) {
                        @unlink($chunkFile);
                    }
                }
                @rmdir($tmpDir);

                // セッションからuploadIdを削除（クリーンアップ）
                $userId = auth()->id() ?? 0;
                $ipAddress = $request->ip();
                $baseKey = md5($originalFileName . $totalChunks . $userId . $ipAddress);
                $sessionKey = 'upload_id_' . $baseKey;
                session()->forget($sessionKey);

                throw new \Exception($errorMessage);
            }

            // ファイルを結合
            $out = fopen($tempFinalPath, 'wb'); // 'ab'から'wb'に変更（新規作成）
            if ($out === false) {
                throw new \Exception('一時ファイルの作成に失敗しました。');
            }

            for ($i = 0; $i < $totalChunks; $i++) {
                $chunkFile = $tmpDir . '/' . $randomFileName . '.part' . $i;

                if (!file_exists($chunkFile)) {
                    fclose($out);
                    if (file_exists($tempFinalPath)) {
                        unlink($tempFinalPath);
                    }
                    throw new \Exception("チャンクファイルが見つかりません: {$i}");
                }

                $in = fopen($chunkFile, 'rb');
                if ($in === false) {
                    fclose($out);
                    if (file_exists($tempFinalPath)) {
                        unlink($tempFinalPath);
                    }
                    throw new \Exception("チャンクファイルの読み込みに失敗しました: {$i}");
                }

                stream_copy_to_stream($in, $out);
                fclose($in);
                unlink($chunkFile); // チャンク削除
            }
            fclose($out);

            // 一時ディレクトリ削除
            rmdir($tmpDir);

            // メディアライブラリ保存
            $fileSize = filesize($tempFinalPath);
            $mimeType = mime_content_type($tempFinalPath);

            try {
                // ファイル検証（拡張子・MIMEタイプ・ファイルサイズ）
                $this->validateUploadedFile($originalFileName, $mimeType, $fileSize);
            } catch (\Exception $e) {
                // 検証失敗時は一時ファイルを削除
                if (file_exists($tempFinalPath)) {
                    unlink($tempFinalPath);
                }
                throw $e;
            }

            // 画像サイズの取得（一時ファイルから取得）
            $imageSize = null;
            if (str_starts_with($mimeType, 'image/')) {
                $imageInfo = getimagesize($tempFinalPath);
                if ($imageInfo !== false) {
                    $imageSize = json_encode([
                        'width' => $imageInfo[0],
                        'height' => $imageInfo[1]
                    ]);
                }
            }

            // ストレージからの相対パスを生成（ランダムファイル名を使用）
            $relativePath = 'uploads/' . $date->format('Y/m/d/') . uniqid() . "/" . $randomFileName;

            // 施設を取得してassignableに設定（バケット名取得のため）
            $companyAndFacility = $this->findCompanyAndFacility($request);
            $company = $companyAndFacility['company'];
            $facility = $companyAndFacility['facility'];

            // Storage経由でファイルを保存（リトライとフォールバック機能付き）
            $disk = $this->saveFileWithRetryAndFallback($disk, $relativePath, $tempFinalPath, $company, $mimeType);

            // 一時ファイルを削除
            unlink($tempFinalPath);

            // URLを取得（企業情報を渡す）
            $fileUrl = $this->getFileUrl($disk, $relativePath, $company);

            // 施設を取得してassignableに設定（既に取得済みなので再利用）
            // $companyAndFacility = $this->findCompanyAndFacility($request);
            // $company = $companyAndFacility['company'];
            // $facility = $companyAndFacility['facility'];

            $mediaData = [
                'file_name' => $originalFileName, // 元のファイル名を保存（表示用）
                'file_path' => $relativePath,  // ストレージからの相対パス（ランダムファイル名）
                'file_url' => $fileUrl,
                'mime_type' => $mimeType,
                'file_size' => $fileSize,
                'image_size' => $imageSize,
                'company_id' => $company->id,
                'assignable_type' => get_class($facility),
                'assignable_id' => $facility->id,
            ];

            if (!$id) {
                $mediaData['sort_num'] = 0;
                $mediaLibrary = $this->model->create($mediaData);
            } else {
                $mediaLibrary = $this->model->find($id);
                $mediaLibrary->update($mediaData);
            }

            // セッションからuploadIdを削除（クリーンアップ）
            $userId = auth()->id() ?? 0;
            $ipAddress = $request->ip();
            $baseKey = md5($originalFileName . $totalChunks . $userId . $ipAddress);
            $sessionKey = 'upload_id_' . $baseKey;
            session()->forget($sessionKey);

            return [
                'status' => 'completed',
                'path' => $relativePath,  // ストレージからの相対パス
                'url' => $fileUrl,
                'media_id' => $mediaLibrary->id
            ];
        }

        return ['status' => 'chunk_received'];
    }

    /**
     * アップロードファイルの検証
     */
    private function validateUploadedFile(string $fileName, string $mimeType, int $fileSize): void
    {
        $config = config('media_library.upload');
        $allowedExtensions = $config['allowed_extensions'] ?? [];
        $allowedMimeTypes = $config['allowed_mime_types'] ?? [];
        $maxFileSize = $config['max_file_size'] ?? 100 * 1024 * 1024;

        // 拡張子の検証
        $extension = strtolower(pathinfo($fileName, PATHINFO_EXTENSION));
        if (empty($extension) || !in_array($extension, $allowedExtensions, true)) {
            throw new \Exception("許可されていないファイル形式です。許可されている拡張子: " . implode(', ', $allowedExtensions));
        }

        // MIMEタイプの検証
        if (empty($mimeType) || !in_array($mimeType, $allowedMimeTypes, true)) {
            throw new \Exception("許可されていないMIMEタイプです。");
        }

        // 拡張子とMIMEタイプの整合性チェック
        $expectedMimeTypes = $this->getExpectedMimeTypes($extension);
        if (!empty($expectedMimeTypes) && !in_array($mimeType, $expectedMimeTypes, true)) {
            throw new \Exception("ファイル拡張子とMIMEタイプが一致しません。");
        }

        // ファイルサイズの検証
        if ($fileSize > $maxFileSize) {
            $maxSizeMB = round($maxFileSize / 1024 / 1024, 2);
            throw new \Exception("ファイルサイズが大きすぎます。最大{$maxSizeMB}MBまでです。");
        }
    }

    /**
     * 拡張子に対応するMIMEタイプを取得
     */
    private function getExpectedMimeTypes(string $extension): array
    {
        $mimeMap = [
            'jpg' => ['image/jpeg'],
            'jpeg' => ['image/jpeg'],
            'png' => ['image/png'],
            'gif' => ['image/gif'],
            'webp' => ['image/webp'],
            'svg' => ['image/svg+xml'],
            'pdf' => ['application/pdf'],
            'doc' => ['application/msword'],
            'docx' => ['application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
            'xls' => ['application/vnd.ms-excel'],
            'xlsx' => ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],
            'txt' => ['text/plain'],
            'csv' => ['text/csv', 'text/plain'],
            'mp4' => ['video/mp4'],
            'mov' => ['video/quicktime'],
            'avi' => ['video/x-msvideo'],
            'wmv' => ['video/x-ms-wmv'],
            'webm' => ['video/webm'],
            'mkv' => ['video/x-matroska'],
        ];

        return $mimeMap[strtolower($extension)] ?? [];
    }

    /**
     * メディアファイルをリネーム（表示用ファイル名のみ更新、実際のファイルは変更しない）
     */
    protected function renameMedia(MediaLibrary $model, string $newFileName)
    {
        // ファイル名（表示用）のみ更新
        // 実際のファイルパスはランダムファイル名のため変更しない
        $model->file_name = $newFileName;
        $model->save();
    }
}
